/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/script.js":
/*!**************************!*\
  !*** ./src/js/script.js ***!
  \**************************/
/***/ (() => {

eval("( function ( window ) {\n\t'use strict';\n\n\tfunction extend( a, b ) {\n\t\treturn Object.assign( a, b );\n\t}\n\n\t// returns the depth of the element \"e\" relative to element with id=id\n\t// for this calculation only parents with classname = waypoint are considered\n\tfunction getLevelDepth( e, id, waypoint ) {\n\t\tlet depthCount = 0;\n\t\twhile ( e ) {\n\t\t\tif ( e.id.indexOf( id ) >= 0 ) {\n\t\t\t\treturn depthCount;\n\t\t\t}\n\t\t\tif ( e.classList.contains( waypoint ) ) {\n\t\t\t\tdepthCount++;\n\t\t\t}\n\t\t\te = e.parentNode;\n\t\t}\n\t\treturn depthCount;\n\t}\n\n\t// returns the closest element to 'e' that has class \"classname\"\n\tfunction closest( e, classname ) {\n\t\treturn e.closest( '.' + classname );\n\t}\n\n\tconst MENU_ID = 'opus-dashboard';\n\tconst CLASS_LEVEL = 'opus-dashboard__level';\n\tconst CLASS_OVERLAY = 'opus-dashboard__level-overlay';\n\tconst CLASS_BACK = 'opus-dashboard__level-back';\n\tconst CLASS_OPEN = 'is-open';\n\tconst CLASS_PUSHED = 'is-pushed';\n\n\t/**\n\t * Offcanvas\n\t *\n\t * @param {Element} element - The menu element.\n\t * @param {Element} trigger - The menu trigger element.\n\t * @param {Object}  options - The options object.\n\t */\n\tfunction opusDashboard( element, trigger, options ) {\n\t\tthis.element = element;\n\t\tthis.trigger = trigger;\n\t\tthis.options = extend( this.defaults, options );\n\t\tthis._init();\n\t}\n\n\topusDashboard.prototype = {\n\t\tdefaults: {\n\t\t\t// space between each overlaped level\n\t\t\tlevelSpacing: 40,\n\t\t\t// classname for the element (if any) that when clicked closes the current level\n\t\t\tbackClass: CLASS_BACK,\n\t\t},\n\n\t\t_init() {\n\t\t\tthis.level = 0;\n\t\t\tthis.menu = document.getElementById( MENU_ID );\n\t\t\tthis.levels = [\n\t\t\t\t...this.element.getElementsByClassName( CLASS_LEVEL ),\n\t\t\t];\n\t\t\t// save the depth of each of these level elements\n\t\t\tthis.levels.forEach( ( element ) => {\n\t\t\t\telement.setAttribute(\n\t\t\t\t\t'data-level',\n\t\t\t\t\tgetLevelDepth( element, this.element.id, CLASS_LEVEL )\n\t\t\t\t);\n\t\t\t} );\n\t\t\tthis.menuItems = [ ...this.element.getElementsByTagName( 'li' ) ];\n\t\t\tthis.levelBack = [\n\t\t\t\t...this.element.getElementsByClassName(\n\t\t\t\t\tthis.options.backClass\n\t\t\t\t),\n\t\t\t];\n\t\t\t// event type (if mobile use touch events)\n\t\t\t// this.eventtype = mobilecheck() ? 'touchstart' : 'click';\n\t\t\tthis.eventtype = 'click';\n\t\t\t// initialize / bind the necessary events\n\t\t\tthis._initEvents();\n\t\t},\n\n\t\t_initEvents() {\n\t\t\tconst self = this;\n\n\t\t\t// the menu should close if clicking somewhere on the body\n\t\t\tconst bodyClick = ( element ) => {\n\t\t\t\tself._resetMenu();\n\t\t\t\telement.removeEventListener( self.eventtype, bodyClick );\n\t\t\t};\n\n\t\t\t// open (or close) the menu\n\t\t\tthis.trigger.addEventListener( this.eventtype, function ( event ) {\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tevent.preventDefault();\n\t\t\t\tif ( self.open ) {\n\t\t\t\t\tself._resetMenu();\n\t\t\t\t} else {\n\t\t\t\t\tself._openMenu();\n\t\t\t\t\t// the menu should close if clicking somewhere on the body (excluding clicks on the menu)\n\t\t\t\t\tdocument.addEventListener(\n\t\t\t\t\t\tself.eventtype,\n\t\t\t\t\t\tfunction ( newEvent ) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tself.open &&\n\t\t\t\t\t\t\t\t! newEvent.target.closest( self.element.id )\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tbodyClick( this );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// opening a sub level menu\n\t\t\tthis.menuItems.forEach( ( menuItem ) => {\n\t\t\t\t// check if it has a sub level\n\t\t\t\tconst subLevel = menuItem.querySelector( `.${ CLASS_LEVEL }` );\n\t\t\t\tif ( subLevel ) {\n\t\t\t\t\tmenuItem\n\t\t\t\t\t\t.querySelector( 'a' )\n\t\t\t\t\t\t.addEventListener( self.eventtype, function ( event ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tconst level = closest(\n\t\t\t\t\t\t\t\tmenuItem,\n\t\t\t\t\t\t\t\tCLASS_LEVEL\n\t\t\t\t\t\t\t).getAttribute( 'data-level' );\n\t\t\t\t\t\t\tif ( self.level <= level ) {\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t\tclosest( menuItem, CLASS_LEVEL ).classList.add(\n\t\t\t\t\t\t\t\t\tCLASS_OVERLAY\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tself._openMenu( subLevel );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\t// closing the sub levels :\n\t\t\t// by clicking on the visible part of the level element\n\t\t\tthis.levels.forEach( ( element ) => {\n\t\t\t\telement.setAttribute(\n\t\t\t\t\t'data-level',\n\t\t\t\t\tgetLevelDepth( element, self.element.id, CLASS_LEVEL )\n\t\t\t\t);\n\t\t\t\telement.addEventListener( self.eventtype, function ( event ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tconst level = element.getAttribute( 'data-level' );\n\t\t\t\t\tif ( self.level > level ) {\n\t\t\t\t\t\tself.level = level;\n\t\t\t\t\t\tself._closeMenu();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\n\t\t\t// by clicking on a specific element\n\t\t\tthis.levelBack.forEach( function ( element ) {\n\t\t\t\telement.addEventListener( self.eventtype, function ( event ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tconst level = closest( element, CLASS_LEVEL ).getAttribute(\n\t\t\t\t\t\t'data-level'\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( self.level <= level ) {\n\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\tself.level =\n\t\t\t\t\t\t\tclosest( element, CLASS_LEVEL ).getAttribute(\n\t\t\t\t\t\t\t\t'data-level'\n\t\t\t\t\t\t\t) - 1;\n\t\t\t\t\t\treturn self.level === 0\n\t\t\t\t\t\t\t? self._resetMenu()\n\t\t\t\t\t\t\t: self._closeMenu();\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t},\n\n\t\t_openMenu( subLevel ) {\n\t\t\t// increment level depth\n\t\t\t++this.level;\n\n\t\t\t// move the main wrapper\n\t\t\tconst levelFactor = ( this.level - 1 ) * this.options.levelSpacing;\n\t\t\tthis._setTransform( `translate3d(-${ levelFactor }px,0,0)` );\n\n\t\t\tif ( subLevel ) {\n\t\t\t\t// reset transform for sublevel\n\t\t\t\tthis._setTransform( '', subLevel );\n\t\t\t\t// need to reset the translate value for the level menus that have the same level depth and are not open\n\t\t\t\tfor ( const levelEl of this.levels ) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tlevelEl !== subLevel &&\n\t\t\t\t\t\t! levelEl.classList.contains( CLASS_OPEN )\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis._setTransform(\n\t\t\t\t\t\t\t'translate3d(100%,0,0) translate3d(-' +\n\t\t\t\t\t\t\t\t-1 * levelFactor +\n\t\t\t\t\t\t\t\t'px,0,0)',\n\t\t\t\t\t\t\tlevelEl\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add class pushed to main wrapper if opening the first time\n\t\t\tif ( this.level === 1 ) {\n\t\t\t\tthis.menu.classList.add( CLASS_PUSHED );\n\t\t\t\tthis.open = true;\n\t\t\t}\n\t\t\t// add class level-open to the opening level element\n\t\t\t( subLevel || this.levels[ 0 ] ).classList.add( CLASS_OPEN );\n\t\t},\n\t\t// close the menu\n\t\t_resetMenu() {\n\t\t\tthis._setTransform( 'translate3d(100%,0,0)' );\n\t\t\tthis.level = 0;\n\t\t\t// remove class mp-pushed from main wrapper\n\t\t\tthis.menu.classList.remove( CLASS_PUSHED );\n\t\t\tthis._toggleLevels();\n\t\t\tthis.open = false;\n\t\t},\n\t\t// close sub menus\n\t\t_closeMenu() {\n\t\t\tconst levelFactor = ( this.level - 1 ) * this.options.levelSpacing;\n\t\t\tthis._setTransform( `translate3d(-${ levelFactor }px,0,0)` );\n\t\t\tthis._toggleLevels();\n\t\t},\n\t\t// translate the element\n\t\t_setTransform( value, element = this.menu ) {\n\t\t\trequestAnimationFrame( () => {\n\t\t\t\telement.style.transform = value;\n\t\t\t} );\n\t\t},\n\t\t// removes classes level-open from closing levels\n\t\t_toggleLevels() {\n\t\t\tfor ( const levelEl of this.levels ) {\n\t\t\t\tif ( levelEl.getAttribute( 'data-level' ) >= this.level + 1 ) {\n\t\t\t\t\tlevelEl.classList.remove( CLASS_OPEN, CLASS_OVERLAY );\n\t\t\t\t} else if (\n\t\t\t\t\tlevelEl.getAttribute( 'data-level' ) === this.level\n\t\t\t\t) {\n\t\t\t\t\tlevelEl.classList.remove( CLASS_OVERLAY );\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t};\n\n\t// add to global namespace\n\twindow.opusDashboard = opusDashboard;\n} )( window );\n\n\n//# sourceURL=webpack://offcanvas/./src/js/script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/script.js"]();
/******/ 	
/******/ })()
;